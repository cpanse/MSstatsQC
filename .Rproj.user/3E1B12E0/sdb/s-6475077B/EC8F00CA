{
    "collab_server" : "",
    "contents" : "COL.BEST.RET <- \"Retention Time\"\nCOL.FWHM <- \"Full Width at Half Maximum\"\nCOL.TOTAL.AREA <- \"Total Peak Area\"\nCOL.PEAK.ASS <- \"Peak Assymetry\"\n#############################################################################################\n#INPUTS : \"prodata\" is the data user uploads.\n#         \"peptide\" is the precursor that user selects in Data Import tab. it can be either one precursor(peptide) or it can be \"all peptides\"\n#         \"L\" and \"U\" are lower and upper bound of guide set that user choose in Data Import tab.\n#         \"metric\" is one of these metrics: COL.BEST.RET,COL.FWHM, COL.TOTAL.AREA,COL.PEAK.ASS or a metric that user defines in his data set\n#         \"normalization\" is either TRUE or FALSE\n#Description of function : it gets the metric column only for the precursor chosen and either return the column as it is or normalize it and then return it\ngetMetricData <- function(prodata, peptide, L, U, metric, normalization) {\n  precursor.data<-prodata[prodata$Precursor==peptide,] #\"Precursor\" is one of the columns in data that shows the name of peptides\n  metricData <- 0\n\n  if(is.null(metric)){\n    return(NULL)\n  }\n\n  metricData = precursor.data[,metric]\n  if(normalization == TRUE) {\n    mu=mean(metricData[L:U]) # in-control process mean\n    sd=sd(metricData[L:U]) # in-control process variance\n    if(sd == 0) {sd <- 0.0001}\n    metricData=scale(metricData[1:length(metricData)],mu,sd) # transformation for N(0,1) )\n    return(metricData)\n  } else if(normalization == FALSE){\n    return(metricData)\n  }\n\n}\n#########################################################################################################\nfind_custom_metrics <- function(prodata) {\n    prodata <- prodata[, which(colnames(prodata)==\"Annotations\"):ncol(prodata),drop = FALSE]\n    nums <- sapply(prodata, is.numeric)\n    other.metrics <- colnames(prodata[,nums])[1:ifelse(length(colnames(prodata[,nums]))<11,\n                                                       length(colnames(prodata[,nums])),\n                                                       10)\n                                              ] # limiting custom metrics up to 10 metrics and not more\n    if(any(is.na(other.metrics))) {\n      return(c())\n    }\n    return(other.metrics)\n}\n################################################################\n#z = metricData\n#INPUT : \"prodata\" is the data user uploads.\n#        \"metricData\" is the column of the data related to the metric we want. Forexample if we want retention time, it gives retention time column\n#        \"peptide\" is the precursor that user selects in Data Import tab. it can be either one precursor(peptide) or it can be \"all peptides\"\n#        \"L\" and \"U\" are lower and upper bound of guide set that user choose in Data Import tab.\n#        \"type\" is either \"mean\" or \"dispersion\".\n#DESCRIPTION : returns a data frame for CUSUM that contains all the information needed to plot CUSUM\nCUSUM.data.prepare <- function(prodata, metricData, peptide, L, U, type) {\n\n  k=0.5\n  #precursor.data only gets the data for the selected precursor\n  precursor.data <- prodata[prodata$Precursor==peptide,] #\"Precursor\" is one of the columns in data that shows the name of peptides\n\n  v <- numeric(length(metricData))\n\n  Cpoz <- numeric(length(metricData))\n  Cneg <- numeric(length(metricData))\n\n  for(i in 2:length(metricData)) {\n    Cpoz[i]=max(0,(metricData[i]-(k)+Cpoz[i-1]))\n    Cneg[i]=max(0,((-k)-metricData[i]+Cneg[i-1]))\n  }\n\n  if(type == \"dispersion\") {\n    for(i in 2:length(metricData)) {\n      v[i]=(sqrt(abs(metricData[i]))-0.822)/0.349\n    }\n    for(i in 2:length(metricData)) {\n      Cpoz[i]=max(0,(v[i]-(k)+Cpoz[i-1]))\n      Cneg[i]=max(0,((-k)-v[i]+Cneg[i-1]))\n    }\n  }\n\n  QCno = 1:length(metricData)\n\n  plot.data =\n    data.frame(QCno = QCno\n               ,CUSUM.poz = Cpoz\n               ,CUSUM.neg = -Cneg\n               ,Annotations=precursor.data$Annotations\n               )\n\n  return(plot.data)\n}\n###################################################################################################\n#z = metricData\n#INPUT : \"prodata\" is the data user uploads.\n#        \"metricData\" is the column of the data related to the metric we want. Forexample if we want retention time, it gives retention time column\n#        \"type\" is either \"mean\" or \"dispersion\".\n#DESCRIPTION : returns a data frame for CP that contains all the information needed to plot Change Point\nCP.data.prepare <- function(prodata, metricData, type) {\n\n  Et <-  numeric(length(metricData)-1) # this is Ct in type = \"mean\", and Dt in type = \"dispersion\".\n  SS<- numeric(length(metricData)-1)\n  SST<- numeric(length(metricData)-1)\n  tho.hat <- 0\n\n  if(type == \"mean\") {\n    ## Change point analysis for mean (Single step change model)\n    for(i in 1:(length(metricData)-1)) {\n      Et[i]=(length(metricData)-i)*(((1/(length(metricData)-i))*sum(metricData[(i+1):length(metricData)]))-0)^2 #change point function\n    }\n    QCno=1:(length(metricData)-1)\n  } else if(type == \"dispersion\") {\n    ## Change point analysis for variance (Single step change model)\n    for(i in 1:length(metricData)) {\n      SS[i]=metricData[i]^2\n    }\n    for(i in 1:length(metricData)) {\n      SST[i]=sum(SS[i:length(metricData)])\n      Et[i]=((SST[i]/2)-((length(metricData)-i+1)/2)*log(SST[i]/(length(metricData)-i+1))-(length(metricData)-i+1)/2) #change point function\n    }\n    QCno=1:length(metricData)\n  }\n  tho.hat = which(Et==max(Et)) # change point estimate\n  plot.data <- data.frame(QCno,Et,tho.hat)\n\n  return(plot.data)\n}\n###################################################################################################\n#INPUT : \"prodata\" is the data user uploads.\n#        \"L\" and \"U\" are lower and upper bound of guide set that user choose in Data Import tab.\n#        \"data.metrics\" is all the available metrics. It is defined in server.R\nget_CP_tho.hat <- function(prodata, L, U, data.metrics) {\n  tho.hat <- data.frame(tho.hat = c(), metric = c(), group = c(), y=c())\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n  for(metric in data.metrics) {\n    for (j in 1:nlevels(prodata$Precursor)) {\n      metricData <- getMetricData(prodata, precursors[j], L, U, metric = metric, normalization = TRUE)\n      mix <- rbind(\n        data.frame(tho.hat = CP.data.prepare(prodata, metricData,type = \"mean\")$tho.hat[1], metric = metric, group = \"Individual Value\", y=1.1),\n        data.frame(tho.hat = CP.data.prepare(prodata, metricData,type = \"dispersion\")$tho.hat[1], metric = metric, group = \"Moving Range\", y=-1.1)\n      )\n      tho.hat <- rbind(tho.hat, mix)\n\n    }\n  }\n\n  return(tho.hat)\n}\n###################################################################################################\n#z = metricData\n#INPUT : \"prodata\" is the data user uploads.\n#        \"metricData\" is the column of the data related to the metric we want. Forexample if we want retention time, it gives retention time column\n#        \"L\" and \"U\" are lower and upper bound of guide set that user choose in Data Import tab.\n#        \"type\" is either \"mean\" or \"dispersion\".\n#DESCRIPTION : returns a data frame for XmR that contains all the information needed to plot XmR\nXmR.data.prepare <- function(prodata, metricData, L,U, type) {\n  t <- numeric(length(metricData)-1)\n\n  for(i in 2:length(metricData)) {\n    t[i]=abs(metricData[i]-metricData[i-1]) # Compute moving range of metricData\n  }\n  #Main=Main.title\n\n  QCno=1:length(metricData)\n\n  if(type == \"mean\") {\n    UCL=mean(metricData[L:U])+2.66*sd(t[L:U])\n    LCL=mean(metricData[L:U])-2.66*sd(t[L:U])\n    t <- metricData\n  } else if(type == \"dispersion\") {\n    ## Calculate MR chart statistics and limits\n\n    UCL=3.267*sd(t[1:L-U])\n    LCL=0\n  }\n  plot.data=data.frame(QCno,metricData,t,UCL,LCL)\n  return(plot.data)\n}\n############################################################################################\n#INPUTS : \"prodata\" is the data user uploads.\n#         \"metric\" is one of these metrics: COL.BEST.RET,COL.FWHM, COL.TOTAL.AREA,COL.PEAK.ASS or a metric that user defines in his data set\n#         \"L\" and \"U\" are lower and upper bound of guide set that user choose in Data Import tab.\n#        \"type\" is either \"mean\" or \"dispersion\".\n#DESCRIPTION : returns a data frame that is used in CUSUM.Summary.DataFrame function below to use for summary plot of CUSUM in Summary Tab of shiny app\nCUSUM.Summary.prepare <- function(prodata, metric, L, U,type) {\n  h <- 5\n\n  QCno <- 1:nrow(prodata)\n  y.poz <- rep(0,nrow(prodata))\n  y.neg <- rep(0,nrow(prodata))\n  counter <- rep(0,nrow(prodata))\n\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L, U, metric = metric, normalization = T)\n    counter[1:length(metricData)] <- counter[1:length(metricData)]+1\n    plot.data <- CUSUM.data.prepare(prodata, metricData, precursors[j], L, U, type)\n\n    sub.poz <- plot.data[plot.data$CUSUM.poz >= h | plot.data$CUSUM.poz <= -h, ]\n    sub.neg <- plot.data[plot.data$CUSUM.neg >= h | plot.data$CUSUM.neg <= -h, ]\n\n    y.poz[sub.poz$QCno] <- y.poz[sub.poz$QCno] + 1\n    y.neg[sub.neg$QCno] <- y.neg[sub.neg$QCno] + 1\n  }\n  max_QCno <- max(which(counter!=0))\n  pr.y.poz = y.poz[1:max_QCno]/counter[1:max_QCno]\n  pr.y.neg = y.neg[1:max_QCno]/counter[1:max_QCno]\n\n  plot.data <- data.frame(QCno = rep(1:max_QCno,2),\n                          pr.y = c(pr.y.poz, pr.y.neg),\n                          group = ifelse(rep(type == \"mean\",2*max_QCno),\n                                         c(rep(\"Metric mean increase\",max_QCno),\n                                           rep(\"Metric mean decrease\",max_QCno)),\n                                         c(rep(\"Metric dispersion increase\",max_QCno),\n                                           rep(\"Metric dispersion decrease\",max_QCno))),\n                          metric = rep(metric,max_QCno*2)\n     )\n  return(plot.data)\n}\n############################################################################################\nCUSUM.Summary.DataFrame <- function(prodata, data.metrics, L, U) {\n  dat <- data.frame(QCno = c(),\n                    pr.y = c(),\n                    group = c(),\n                    metric = c())\n  for (metric in data.metrics) {\n    data.1   <- CUSUM.Summary.prepare(prodata, metric = metric, L, U,type = \"mean\")\n    data.2   <- CUSUM.Summary.prepare(prodata, metric = metric, L, U,type = \"dispersion\")\n    data.2$pr.y <- -(data.2$pr.y)\n    dat <- rbind(dat,data.1,data.2)\n  }\n  return(dat)\n}\n############################################################################################\nCUSUM.heatmap.DataFrame <- function() {\n\n}\n############################################################################################\n#DESCRIPTION : for each metric returns a data frame of QCno, probability of out of control peptide for dispersion or mean plot\nXmR.Summary.prepare <- function(prodata, metric, L, U,type) {\n  QCno    <- 1:nrow(prodata)\n  y.poz <- rep(0,nrow(prodata))\n  y.neg <- rep(0,nrow(prodata))\n  counter <- rep(0,nrow(prodata))\n\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L = L, U = U, metric = metric, normalization = T)\n    counter[1:length(metricData)] <- counter[1:length(metricData)]+1\n    plot.data <- XmR.data.prepare(prodata, metricData , L , U , type)\n\n    sub.poz <- plot.data[plot.data$t >= plot.data$UCL, ]\n    sub.neg <- plot.data[plot.data$t <= plot.data$LCL, ]\n\n    y.poz[sub.poz$QCno] <- y.poz[sub.poz$QCno] + 1\n    y.neg[sub.neg$QCno] <- y.neg[sub.neg$QCno] + 1\n  }\n  max_QCno <- max(which(counter!=0))\n  pr.y.poz = y.poz[1:max_QCno]/counter[1:max_QCno]\n  pr.y.neg = y.neg[1:max_QCno]/counter[1:max_QCno]\n\n  plot.data <- data.frame(QCno = rep(1:max_QCno,2),\n                          pr.y = c(pr.y.poz, pr.y.neg),\n                          group = ifelse(rep(type == \"mean\",2*max_QCno),\n                                         c(rep(\"Metric mean increase\",max_QCno),\n                                           rep(\"Metric mean decrease\",max_QCno)),\n                                         c(rep(\"Metric dispersion increase\",max_QCno),\n                                           rep(\"Metric dispersion decrease\",max_QCno))),\n                          metric = rep(metric,max_QCno*2))\n\n  return(plot.data)\n}\n###########################################################################################\n#DESCRIPTION : returns a data frame for all the metrics, probability of out of range peptides, wheter it is for metric mean or metric dispersion and i is an increase or decrease\nXmR.Summary.DataFrame <- function(prodata, data.metrics, L, U) {\n  dat <- data.frame(QCno = c(),\n                    pr.y = c(),\n                    group = c(),\n                    metric = c())\n  for (metric in data.metrics) {\n    data.1   <- XmR.Summary.prepare(prodata, metric = metric, L, U,type = \"mean\")\n    data.2   <- XmR.Summary.prepare(prodata, metric = metric, L, U,type = \"dispersion\")\n    data.2$pr.y <- -(data.2$pr.y)\n    dat <- rbind(dat, data.1, data.2)\n  }\n  return(dat)\n}\n############################################################################################\nXmR.heatmap.DataFrame <- function(prodata,peptide, L, U, type) {\n\n  metricDataRT <- getMetricData(prodata, peptide, L = L, U = U, metric = COL.BEST.RET, normalization = F)\n  RT <- XmR.data.prepare(prodata, metricDataRT, L, U, type)$t\n  RT_UCL <- XmR.data.prepare(prodata, metricDataRT, L, U, type)$UCL\n  RT_LCL <- XmR.data.prepare(prodata, metricDataRT, L, U, type)$LCL\n\n  metricDataPA <- getMetricData(prodata, peptide, L = L, U = U, metric = COL.PEAK.ASS, normalization = F)\n  PA <- XmR.data.prepare(prodata, metricDataPA, L, U, type)$t\n  PA_UCL <- XmR.data.prepare(prodata, metricDataPA, L, U, type)$UCL\n  PA_LCL <- XmR.data.prepare(prodata, metricDataPA, L, U, type)$LCL\n\n  metricDataFWHM <- getMetricData(prodata, peptide, L = L, U = U, metric = COL.FWHM, normalization = F)\n  FWHM <- XmR.data.prepare(prodata, metricDataFWHM, L, U, type)$t\n  FWHM_UCL <- XmR.data.prepare(prodata, metricDataFWHM, L, U, type)$UCL\n  FWHM_LCL <- XmR.data.prepare(prodata, metricDataFWHM, L, U, type)$LCL\n\n  metricDataTPA <- getMetricData(prodata, peptide, L = L, U = U, metric = COL.TOTAL.AREA, normalization = F)\n  TPA <- XmR.data.prepare(prodata, metricDataTPA, L, U, type)$t\n  TPA_UCL <- XmR.data.prepare(prodata, metricDataTPA, L, U, type)$UCL\n  TPA_LCL <- XmR.data.prepare(prodata, metricDataTPA, L, U, type)$LCL\n\n  dataFrame <- data.frame(RT = RT,\n                          #RT_UCL = RT_UCL, RT_LCL = RT_LCL,\n                        PA = PA,\n                        #PA_UCL = PA_UCL, PA_LCL = PA_LCL,\n                        FWHM = FWHM,\n                        #FWHM_UCL = FWHM_UCL, FWHM_LCL = FWHM_LCL,\n                        TPA = TPA\n                        #,TPA_UCL = TPA_UCL, TPA_LCL = TPA_LCL\n                        )\n\n  return(dataFrame)\n}\n############################################################################################\nCompute.QCno.OutOfRangePeptide.XmR <- function(prodata,L,U,metric,type, XmR.type) {\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n  QCno.out.range <- c()\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L = L, U = U, metric = metric, normalization = T)\n    plot.data <- XmR.data.prepare(prodata, metricData , L = L, U = U, type = type)\n    if(XmR.type == \"poz\")\n      QCno.out.range <- c(QCno.out.range,length(plot.data[plot.data$t >= plot.data$UCL, ]$QCno))\n    else\n      QCno.out.range <- c(QCno.out.range,length(plot.data[plot.data$t <= plot.data$LCL, ]$QCno))\n  }\n  return(QCno.out.range)\n}\n#############################################################################################\nCompute.QCno.OutOfRangePeptide.CUSUM <- function(prodata,L,U,metric,type, CUSUM.type) {\n  h <- 5\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n  QCno.out.range <- c()\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L, U, metric = metric, normalization = T)\n    plot.data <- CUSUM.data.prepare(prodata, metricData, precursors[j], L, U, type)\n    if(CUSUM.type == \"poz\")\n      QCno.out.range <- c(QCno.out.range,length(plot.data[plot.data$CUSUM.poz >= h | plot.data$CUSUM.poz <= -h, ]$QCno))\n    else\n    QCno.out.range <- c(QCno.out.range,length(plot.data[plot.data$CUSUM.neg >= h | plot.data$CUSUM.neg <= -h, ]$QCno))\n  }\n  return(QCno.out.range)\n}\n###############################################################################################################\nXmR.Radar.Plot.prepare <- function(prodata,L,U, metric, type,group, XmR.type) {\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n  precursors2 <- substring(precursors, first = 1, last = 3)\n  QCno.length <- c()\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L = L, U = U, metric = metric, normalization = T)\n    QCno.length <- c(QCno.length,length(metricData))\n  }\n  dat <- data.frame(peptides = precursors2,\n             OutRangeQCno  = Compute.QCno.OutOfRangePeptide.XmR(prodata,L,U,metric = metric,type = type, XmR.type),\n             group         = rep(group,length(precursors)),\n             orderby       = seq(1:length(precursors)),\n             metric        = rep(metric, length(precursors)),\n             tool          = rep(\"XmR\",length(precursors)),\n             probability   = (Compute.QCno.OutOfRangePeptide.XmR(prodata,L,U,metric = metric,type = type, XmR.type)/QCno.length)\n             )\n\n  return(dat)\n}\n################################################################################################\nXmR.Radar.Plot.DataFrame <- function(prodata, data.metrics, L,U) {\n  dat <- data.frame(peptides = c(), OutRangeQCno = c(), group = c(),\n                    orderby = c(), metric = c(), tool = c(),\n                    probability   = c()\n                    )\n  for (metric in data.metrics) {\n    data.1 <- XmR.Radar.Plot.prepare(prodata,L,U,metric = metric,type = \"mean\",group = \"Metric mean increase\", XmR.type = \"poz\")\n    data.2 <- XmR.Radar.Plot.prepare(prodata,L,U,metric = metric,type = \"mean\",group = \"Metric mean decrease\", XmR.type = \"neg\")\n    data.3 <- XmR.Radar.Plot.prepare(prodata,L,U,metric = metric,type = \"dispersion\",group = \"Metric dispersion increase\", XmR.type = \"poz\")\n    data.4 <- XmR.Radar.Plot.prepare(prodata,L,U,metric = metric,type = \"dispersion\",group = \"Metric dispersion decrease\", XmR.type = \"neg\")\n    dat <- rbind(dat, data.1, data.2, data.3, data.4)\n  }\n  return(dat)\n}\n#################################################################################################################\nCUSUM.Radar.Plot.prepare <- function(prodata,L,U, metric,type,group, CUSUM.type) {\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n  precursors2 <- substring(precursors, first = 1, last = 3)\n  QCno.length <- c()\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L = L, U = U, metric = metric, normalization = T)\n    QCno.length <- c(QCno.length,length(metricData))\n  }\n  dat <- data.frame(peptides = precursors2,\n                    OutRangeQCno  = Compute.QCno.OutOfRangePeptide.CUSUM(prodata,L,U,metric = metric,type = type, CUSUM.type),\n                    group         = rep(group,length(precursors)),\n                    orderby       = seq(1:length(precursors)),\n                    metric        = rep(metric, length(precursors)),\n                    tool          = rep(\"XmR\",length(precursors)),\n                    probability   = (Compute.QCno.OutOfRangePeptide.CUSUM(prodata,L,U,metric = metric,type = type, CUSUM.type)/QCno.length)\n  )\n  return(dat)\n}\n#################################################################################################\nCUSUM.Radar.Plot.DataFrame <- function(prodata, data.metrics, L,U) {\n  dat <- data.frame(peptides = c(), OutRangeQCno = c(), group = c(),\n                    orderby = c(), metric = c(), tool = c(),\n                    probability   = c()\n  )\n  for (metric in data.metrics) {\n   data.1 <- CUSUM.Radar.Plot.prepare(prodata,L,U, metric = metric,type = \"mean\", group = \"Metric mean increase\", CUSUM.type = \"poz\")\n   data.2 <- CUSUM.Radar.Plot.prepare(prodata,L,U, metric = metric,type = \"mean\", group = \"Metric mean decrease\", CUSUM.type = \"neg\")\n   data.3 <- CUSUM.Radar.Plot.prepare(prodata,L,U, metric = metric,type = \"dispersion\", group = \"Metric dispersion increase\", CUSUM.type = \"poz\")\n   data.4 <- CUSUM.Radar.Plot.prepare(prodata,L,U, metric = metric,type = \"dispersion\", group = \"Metric dispersion decrease\", CUSUM.type = \"neg\")\n   dat <- rbind(dat, data.1, data.2, data.3, data.4)\n  }\n  return(dat)\n}\n#######################################################################################################\nXmR.Decision.DataFrame.prepare <- function(prodata, metric, L, U,type) {\n\n  QCno    <- 1:nrow(prodata)\n  y <- rep(0,nrow(prodata))\n  counter <- rep(0,nrow(prodata))\n\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L = L, U = U, metric = metric, normalization = T)\n    counter[1:length(metricData)] <- counter[1:length(metricData)]+1\n    plot.data <- XmR.data.prepare(prodata, metricData , L , U , type)\n\n    sub1 <- plot.data[plot.data$t >= plot.data$UCL, ]\n    sub2 <- plot.data[plot.data$t <= plot.data$LCL, ]\n    sub <- rbind(sub1,sub2)\n\n    y[sub$QCno] <- y[sub$QCno] + 1\n  }\n  max_QCno <- max(which(counter!=0))\n  pr.y = y[1:max_QCno]/counter[1:max_QCno]\n\n  plot.data <- data.frame(QCno = rep(1:max_QCno,1),\n                          pr.y = pr.y,\n                          group = ifelse(rep(type == \"mean\",max_QCno),\n                                         rep(\"Metric mean\",max_QCno),\n                                         rep(\"Metric dispersion\",max_QCno)\n                                        ),\n                          metric = rep(metric,max_QCno)\n                          )\n\n  return(plot.data)\n}\n#######################################################################################################\nXmR.number.Of.Out.Of.Range.Metrics <- function(prodata,data.metrics, peptideThreshold, L, U, type) {\n\n  metricCounter = 0\n  for (metric in data.metrics) {\n    data <- XmR.Decision.DataFrame.prepare(prodata, metric, L, U,type)\n    if(nrow(data[data$pr.y > peptideThreshold,]) > 0)\n      metricCounter = metricCounter + 1\n  }\n    return(metricCounter)\n}\n#######################################################################################################\nCUSUM.Decision.DataFrame.prepare <- function(prodata, metric, L, U, type) {\n  h <- 5\n\n  QCno <- 1:nrow(prodata)\n  y <- rep(0,nrow(prodata))\n  counter <- rep(0,nrow(prodata))\n\n  precursors <- levels(reorder(prodata$Precursor,prodata[,COL.BEST.RET]))\n\n  for(j in 1:length(precursors)) {\n    metricData <- getMetricData(prodata, precursors[j], L, U, metric = metric, normalization = T)\n    counter[1:length(metricData)] <- counter[1:length(metricData)]+1\n    plot.data <- CUSUM.data.prepare(prodata, metricData, precursors[j], L, U, type)\n\n    sub1 <- plot.data[plot.data$CUSUM.poz >= h | plot.data$CUSUM.poz <= -h, ]\n    sub2 <- plot.data[plot.data$CUSUM.neg >= h | plot.data$CUSUM.neg <= -h, ]\n    sub <- rbind(sub1,sub2)\n\n    y[sub$QCno] <- y[sub$QCno] + 1\n  }\n\n  max_QCno <- max(which(counter!=0))\n\n  pr.y = y[1:max_QCno]/counter[1:max_QCno]\n\n  plot.data <- data.frame(QCno = rep(1:max_QCno,1),\n                          pr.y = pr.y,\n                          group = ifelse(rep(type == \"mean\",max_QCno),\n                                         rep(\"Metric mean\",max_QCno),\n                                         rep(\"Metric dispersion\",max_QCno)\n                                         ),\n                          metric = rep(metric,max_QCno)\n  )\n\n  return(plot.data)\n}\n####################################################################################################\nCUSUM.number.Of.Out.Of.Range.Metrics <- function(prodata, data.metrics, peptideThreshold, L, U, type) {\n  metricCounter = 0\n  for (metric in data.metrics) {\n    data <- CUSUM.Decision.DataFrame.prepare(prodata, metric, L, U,type)\n\n    if(nrow(data[data$pr.y > peptideThreshold,]) > 0)\n      metricCounter = metricCounter + 1\n  }\n  return(metricCounter)\n}\n",
    "created" : 1483810227306.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "128|57|144|0|\n181|63|216|0|\n218|66|230|0|\n232|39|234|0|\n237|61|270|0|\n273|64|285|0|\n287|64|320|0|\n322|83|335|0|\n337|87|351|0|\n353|79|371|0|\n373|66|386|0|\n388|82|405|0|\n407|68|420|0|\n422|72|454|0|\n456|100|465|0|\n467|75|502|0|\n504|103|513|0|\n",
    "hash" : "3569891654",
    "id" : "EC8F00CA",
    "lastKnownWriteTime" : 1483807669,
    "last_content_update" : 1483810496811,
    "path" : "~/GitHub/MSstatsQC/R/QCMetrics.R",
    "project_path" : "R/QCMetrics.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}